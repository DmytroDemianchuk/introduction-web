{"ast":null,"code":"import { getTabbableNodes } from './utils/DOMutils';\nfunction weakRef(value) {\n  if (!value) return null;\n  var w = value ? new WeakRef(value) : null;\n  return function () {\n    return (w === null || w === void 0 ? void 0 : w.deref()) || null;\n  };\n}\nexport var recordElementLocation = function (element) {\n  var stack = [];\n  var currentElement = element;\n  while (currentElement && currentElement !== document.body) {\n    stack.push({\n      current: weakRef(currentElement),\n      parent: weakRef(currentElement.parentElement),\n      left: weakRef(currentElement.previousElementSibling),\n      right: weakRef(currentElement.nextElementSibling)\n    });\n    currentElement = currentElement.parentElement;\n  }\n  return {\n    element: weakRef(element),\n    stack: stack,\n    ownerDocument: element.ownerDocument\n  };\n};\nvar restoreFocusTo = function (location) {\n  var _a, _b, _c, _d, _e;\n  var stack = location.stack,\n    ownerDocument = location.ownerDocument;\n  var visibilityCache = new Map();\n  for (var _i = 0, stack_1 = stack; _i < stack_1.length; _i++) {\n    var line = stack_1[_i];\n    var parent_1 = (_a = line.parent) === null || _a === void 0 ? void 0 : _a.call(line);\n    // is it still here?\n    if (parent_1 && ownerDocument.contains(parent_1)) {\n      var left = (_b = line.left) === null || _b === void 0 ? void 0 : _b.call(line);\n      var right = (_c = line.right) === null || _c === void 0 ? void 0 : _c.call(line);\n      var focusables = getTabbableNodes([parent_1], visibilityCache);\n      var aim =\n      // that is element itself\n      (_e = (_d = left === null || left === void 0 ? void 0 : left.nextElementSibling) !== null && _d !== void 0 ? _d :\n      // or somebody to the right?\n      right) !== null && _e !== void 0 ? _e :\n      // or somebody to the left\n      left;\n      while (aim) {\n        for (var _f = 0, focusables_1 = focusables; _f < focusables_1.length; _f++) {\n          var focusable = focusables_1[_f];\n          if (aim === null || aim === void 0 ? void 0 : aim.contains(focusable.node)) {\n            return focusable.node;\n          }\n        }\n        aim = aim.nextElementSibling;\n      }\n      if (focusables.length) {\n        // if parent contains a focusable - move there\n        return focusables[0].node;\n      }\n    }\n  }\n  // nothing matched\n  return undefined;\n};\n/**\n * Captures the current focused element to restore focus as close as possible in the future\n * Handles situations where the focused element is removed from the DOM or no longer focusable\n * moving focus to the closest focusable element\n * @param targetElement - element where focus should be restored\n * @returns a function returning a new element to focus\n */\nexport var captureFocusRestore = function (targetElement) {\n  var location = recordElementLocation(targetElement);\n  return function () {\n    return restoreFocusTo(location);\n  };\n};","map":{"version":3,"names":["getTabbableNodes","weakRef","value","w","WeakRef","deref","recordElementLocation","element","stack","currentElement","document","body","push","current","parent","parentElement","left","previousElementSibling","right","nextElementSibling","ownerDocument","restoreFocusTo","location","_a","_b","_c","_d","_e","visibilityCache","Map","_i","stack_1","length","line","parent_1","call","contains","focusables","aim","_f","focusables_1","focusable","node","undefined","captureFocusRestore","targetElement"],"sources":["/Users/apple/Desktop/it/github/introduction-web/client/node_modules/focus-lock/dist/es2015/return-focus.js"],"sourcesContent":["import { getTabbableNodes } from './utils/DOMutils';\nfunction weakRef(value) {\n    if (!value)\n        return null;\n    var w = value ? new WeakRef(value) : null;\n    return function () { return (w === null || w === void 0 ? void 0 : w.deref()) || null; };\n}\nexport var recordElementLocation = function (element) {\n    var stack = [];\n    var currentElement = element;\n    while (currentElement && currentElement !== document.body) {\n        stack.push({\n            current: weakRef(currentElement),\n            parent: weakRef(currentElement.parentElement),\n            left: weakRef(currentElement.previousElementSibling),\n            right: weakRef(currentElement.nextElementSibling),\n        });\n        currentElement = currentElement.parentElement;\n    }\n    return {\n        element: weakRef(element),\n        stack: stack,\n        ownerDocument: element.ownerDocument,\n    };\n};\nvar restoreFocusTo = function (location) {\n    var _a, _b, _c, _d, _e;\n    var stack = location.stack, ownerDocument = location.ownerDocument;\n    var visibilityCache = new Map();\n    for (var _i = 0, stack_1 = stack; _i < stack_1.length; _i++) {\n        var line = stack_1[_i];\n        var parent_1 = (_a = line.parent) === null || _a === void 0 ? void 0 : _a.call(line);\n        // is it still here?\n        if (parent_1 && ownerDocument.contains(parent_1)) {\n            var left = (_b = line.left) === null || _b === void 0 ? void 0 : _b.call(line);\n            var right = (_c = line.right) === null || _c === void 0 ? void 0 : _c.call(line);\n            var focusables = getTabbableNodes([parent_1], visibilityCache);\n            var aim = \n            // that is element itself\n            (_e = (_d = left === null || left === void 0 ? void 0 : left.nextElementSibling) !== null && _d !== void 0 ? _d : \n            // or somebody to the right?\n            right) !== null && _e !== void 0 ? _e : \n            // or somebody to the left\n            left;\n            while (aim) {\n                for (var _f = 0, focusables_1 = focusables; _f < focusables_1.length; _f++) {\n                    var focusable = focusables_1[_f];\n                    if (aim === null || aim === void 0 ? void 0 : aim.contains(focusable.node)) {\n                        return focusable.node;\n                    }\n                }\n                aim = aim.nextElementSibling;\n            }\n            if (focusables.length) {\n                // if parent contains a focusable - move there\n                return focusables[0].node;\n            }\n        }\n    }\n    // nothing matched\n    return undefined;\n};\n/**\n * Captures the current focused element to restore focus as close as possible in the future\n * Handles situations where the focused element is removed from the DOM or no longer focusable\n * moving focus to the closest focusable element\n * @param targetElement - element where focus should be restored\n * @returns a function returning a new element to focus\n */\nexport var captureFocusRestore = function (targetElement) {\n    var location = recordElementLocation(targetElement);\n    return function () {\n        return restoreFocusTo(location);\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}